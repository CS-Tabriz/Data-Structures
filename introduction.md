# درسنامه لیست‌های پیوندی (Linked Lists)
## فهرست

##  لیست پیوندی چیست؟

لیست پیوندی یک <b>ساختار داده‌ای خطی</b> است که از مجموعه‌ای از <b>'گره'ها (Node)</b> ساخته شده است.
هر 'گره' شامل دو بخش است:


در لیست پیوندی شما میتواند هر آیتم را در هر کجای حافظه قرار دهید، اما باید جایگاه آیتم بعدی را هم در کنار آن آیتم قرار بدهید، در واقع لیست پیوندی مجموعه ای از داده ها است که به صورت پراکنده در حافظه ذخیره‌ شدند و هر کدام با داشتن آدرس گره بعدی در حافظه به آن متصل شدند.
<br>
<br>

هر "node" یا "گره" در یک لیست پیوندی به دو قسمت نیاز دارد:
<br>

- <b>دیتا (Data)</b>: داده‌ای که 'گره' نگه می‌دارد
- <b>اشاره‌گر (Pointer/Next)</b>: آدرس 'گره' بعدی

```
      +-----------+-----------+
      |   DATA    |   POINTER |
      |  (مقدار)    | (آدرس بعدی) |
      +-----------+-----------+
            \           /
             \_________/
                  |
              یک گره (Node)
```
به زبان ساده: به جای اینکه مثل آرایه، همه‌ی عناصر کنار هم در حافظه باشند هر 'گره' خودش می‌داند 'گره' بعدی کجاست.

---
##  ساختار یک 'گره' و لیست پیوندی

### ساختار node یا گره
```text
Data | Next
```
برای ساخت یک گره حداقل نیاز به یک داده برای ذخیره و یک pointer برای اشاره به گره بعدی نیاز داریم.
### مثال

```
Memory Addresses:            1001         1020          1190
Nodes:                     [10|1020] -> [20|1190] -> [30|Next] -> None
```

-  شروع لیست از <b>"Head"</b> است که به اولین گره لیست اشاره می‌کند.
-   به آخرین گره لیست که اشاره‌گرش `null` است <b>"Tail"</b> یا "دم" می‌گویند.

### شکل شماتیک
```
Head                          Tail
  |                             |
  v                             v
[10|Next] -> [20|Next] -> [30|Next] -> Null
```


---
##  عملیات روی لیست پیوندی

### عملیات درج

تصور کنید که می‌خواهیم گره B (گره جدید) را بین گره A (گره چپ) و گره C (گره راست) درج کنیم.
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(C)] ----------------------------> [Data|Next]



                            [Data|Next]

                                ^
                                |
                            B(New node)
```
در این صورت B باید به C به عنوان next اشاره کند:

`B.next -−> C;`
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(C)] ----------------------------> [Data|Next]

                                                     ^
                                                     |
                         [Data|Next(C)]--------------/

                                ^
                                |
                            B(New node)
```
اینک گره سمت راست (A) باید به گره جدید (B) اشاره کند:

`A.next -−> B;`
```
     A(Left node)                              C(Right node)
          |                                           |
          v                                           v
    [Data|Next(B)]                               [Data|Next]
            |
            |                                         ^
            |                                         |
            \-----------> [Data|Next(C)]--------------/

                                ^
                                |
                            B(New node)
```
بدین ترتیب گره جدید در میان دو گره قبلی قرار می‌گیرد. لیست جدید به صورت زیر خواهد بود:
```
     A(Left node)                                    C(Right node)
          |                                                |
          v                                                v
    [Data|Next(B)]---------> [Data|Next(C)]---------> [Data|Next]

                                   ^
                                   |
                               B(New node)
```
اگر بخواهیم گرهی را در ابتدای لیست اضافه کنیم نیز مراحل مشابهی را طی می‌کنیم، فقط در یک سمت بجای گره، head را داریم.

 همچنین زمانی که می‌خواهیم گرهی را در انتهای لیست درج کنیم، گره جدید به یک مقدار null اشاره خواهد کرد.
<br>
<br>
### عملیات حذف
ابتدا گره هدف که می‌خواهیم حذف کنیم را با استفاده از الگوریتم‌های جستجو می‌یابیم.

فرض کنید اینبار میخواهیم گره B را از میان A و C حذف کنیم:
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(B)]---------> [Data|Next(C)]---------> [Data|Next]
```
گره چپ (A) باید به گره راست هدف (C یا همان B.next) اشاره کند:

`A.next −-> C;`
```
     A(Left node)           B(Target node)           C(Right node)
          |                        |                       |
          v                        v                       v
    [Data|Next(C)]          [Data|Next(C)]---------> [Data|Next]
             |                                            ^
             |                                            |
             \____________________________________________/
```
با این کار پیوندی که از گره راست (A) به گره هدف (B) وجود داشت از بین می‌رود.

 ما می‌توانیم گره حذف شده (B) را در حافظه نگه داریم ولی حالا که نیازی به آن نداریم می‌توانیم به سادگی آن را به طور کامل پاک کنیم و حافظه اشغال شده را آزاد کنیم:

`Delete(node B);`
```
     A(Left node)            C(Right node)
          |                         |
          v                         v
    [Data|Next(C)] ----------> [Data|Next]
```
<br>


##  انواع لیست‌ پیوندی
چند مدل لیست پیوندی داریم که اینجا می‌بینیم:
### لیست پیوندی یک‌طرفه (Singly Linked List)

```
Head
  |
  v
[10|Next] -> [20|Next] -> [30|Next] -> None
```
 نوع عادی و اولیه لیست پیوندی که حداقل به دو قسمت داده و اشاره‌گر نیاز دارد و در بالا توضیح داده شد.

>لیست پیوندی یک‌‌طرفه در پیاده‌سازی صف‌ها، پشته‌ها و برخی از الگوریتم‌ های مرتب‌سازی کاربرد دارد.

---

### لیست پیوندی دو طرفه (Doubly Linked List)

```
None <- [Prev|10|Next] <-> [Prev|20|Next] <-> [Prev|30|Next] -> None
```
گره های این مدل لیست پیوندی هم به عنصر بعدی‌شان اشاره می‌کنند، هم به قبلی.

در واقع با استفاده از یک اشاره‌گر دیگر (Prev) به عضو قبلی هم اشاره می‌کنند. پس به عقب هم می‌توان پیمایش کرد، ولی برای ذخیره اشاره‌گر اضافی به حافظه بیشتری نیاز است.

 لیست های پیوندی دو طرفه انعطاف‌پذیری بیشتری دارند و
عملیات درج و حذف عناصر در وسط لیست به دلیل وجود اشاره‌گر به گره قبلی، سریع‌تر انجام می‌شود.<br>
 بیشترین کاربرد این نوع لیست پیوندی در پیاده‌سازی گراف‌ها است.


---

### لیست پیوندی حلقوی (Circular Linked List)

```
     ___________________________
    /                           \
    |                           |
    v                           |
[10|Next] -> [20|Next] -> [30|Next]

```
این لیست پیوندی ساختار دایره‌ای دارد. در واقع، اشاره‌گر  آخرین گره به گره اول اشاره می‌کند و یک ساختار دایره‌ای را تشکیل می‌دهد.

 همچنین پیمایش مداومی دارد و می‌توان از هر گره‌ شروع کرده و به همان گره بازگشت.<br>
 کاربرد لیست های پیوندی حلقوی در پیاده‌سازی صف‌های حلقوی و مدیریت حافظه است.

این نوع لیست پیوندی می‌تواند هم به صورت یک طرفه، و هم دو طرفه باشد.

<br>


##  ضمیمه 1 - مزایا و معایب
<details>
<summary> نمایش </summary>

### ساختار حافظه
**آرایه:** داده‌ها به‌صورت پشت سر هم ذخیره می‌شوند و اندازه ثابت است.<br>
**لیست پیوندی:** گره‌ها می‌توانند در هر جای حافظه باشند و اندازه پویا است.

 >⚠️نکته: لیست پیوندی به دلیل ذخیرهٔ اشاره‌گر، نسبت به آرایه حافظهٔ بیشتری اشغال می‌کند.

### سرعت دسترسی

**آرایه:** دسترسی مستقیم و بسیار سریع به هر عنصر: (1)O<br>
**لیست پیوندی:** نیاز به پیمایش: O(n)



### انعطاف‌پذیری
**آرایه:** ساختار ثابت و غیر قابل تغییر، انعطاف‌پذیری کم.<br>
**لیست پیوندی:** ساختار پویا و قابل تغییر، انعطاف‌پذیری بالاتر.


### پیمایش
**آرایه:** به هر شکل دلخواه با سرعت بالا.<br>
**لیست پیوندی:** در لیست های پیوندی یک‌طرفه امکان پیمایش به عقب وجود ندارد.

</details>
<br>

##  ضمیمه 2 - کاربرد در زندگی واقعی
<details>
<summary> نمایش </summary>

### تاریخچه مرورگر وب (Back/Forward Button)

 وقتی شما در مرورگر خود از صفحهای به صفحه دیگر میروید، آدرس هر صفحه به عنوان یک "گره" در یک **لیست پیوندی دوطرفه** ذخیره می‌شود.
- **گره فعلی:** صفحهای که هم اکنون میبینید.
- **دکمه Back (عقب):** اشاره‌گر را به گره قبلی در لیست منتقل می‌کند.
- **دکمه Forward (جلو):** اشاره‌گر را به گره بعدی در لیست منتقل می‌کند.

### پخش کننده موسیقی (Playlist)

 هر آهنگ یک گره است که حاوی داده‌های آهنگ و یک اشاره‌گر به آهنگ بعدی است.
- **قابلیت پخش متوالی:** پخش کننده به راحتی از یک آهنگ به آهنگ بعدی می‌رود.
- **حذف و اضافه کردن آهنگ:** فقط با تغییر اشاره‌گرهای گره‌های قبلی و بعدی انجام می‌شود.


### سیستم Undo / Redo در نرم‌افزارها

در نرم‌افزارهایی مانند Word و Photoshop:
 هر عمل کاربر به عنوان یک گره در **لیست پیوندی دوطرفه** ذخیره می‌شود.
- **دکمه Undo:** اشاره‌گر را به گره قبلی منتقل می‌کند.
- **دکمه Redo:** اشاره‌گر را به گره بعدی برمی‌گرداند.


### پیاده سازی ساختار داده‌ها، مثل:
- صف
- پشته
- بخش هایی از جدول هش

### نکته:
برخلاف تصور لیست های پایتون از لیست پیوندی استفاده نمی‌کنند و در واقع آرایه‌های پویا یا همان `Dynamic Arrays` هستند.
</br>
</details>
