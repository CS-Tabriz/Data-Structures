# مقدمه

الگوریتم یعنی مجموعه‌ای از دستورالعمل‌های گام‌به‌گام که مسئله‌ای را حل می‌کنند. در تحلیل الگوریتم‌ها بیش‌تر به کارایی (زمان اجرا) و مصرف فضا توجه می‌کنیم. در این جزوه روی زمان اجرا تمرکز شده و مروری هم بر اصول ریاضی خواهیم داشت.

> ## مقدمات ریاضی
> ---
>> ### * خواص سیگما :
> * $\sum_{i=1}^n i = 1+2+3+ ... + n= \frac{n(n+1)}{2}$ ~ $\frac{1}{2}n^2= \Theta(n^2)$
> * $\sum_{i=1}^{n} i^2 = 1^2 +2^2 + 3^2 + ...+ n^2 = \frac{n(n+1)(2n+1)}{6}$ ~ $\frac{1}{3}n^3=\Theta(n^3)$
> * $\sum_{i=1}^{n} i^3 = 1^3 +2^3 + 3^3 + ...+ n^3 = \left( \frac{n(n+1)}{2} \right)^2$ ~ $\frac{1}{4}n^4=\Theta(n^4)$
>
>     * $\sum_{i=1}^{n} i^{p>0} = 1^p +2^p + 3^p + ...+ n^p$ ~ $\frac{1}{p+1}n^{p+1}=\Theta(n^{p+1})$
> 
> #### مثال :
> ### $\lim_{n\to \infty} \frac{1 + 2^5 + 3^5+ ... + n^5}{\frac{2}{3}n^6} = \frac{\frac{1}{6}n^6}{\frac{2}{3}n^6} = \frac{1}{4}$
> 
> * $\sum_{i=1}^{n} \frac{1}{i} = 1 + \frac{1}{2}+ \frac{1}{3}+ ... + \frac{1}{n}= \Theta(\log n)$
> * $\sum_{i=0}^{n-1} ax^i = a + ax + ax^2 + ...+ ax^{n-1} = a\left(\frac{x^n - 1}{x -1} \right) ; x>1$
>
> * $\sum_{i=0}^{\infty} ax^i = a + ax + ax^2 + ...+ ax^{n-1} = \frac{a}{x -1} ; |x|<1$ 
> #### مثال:
> #### آرسام بالاخره می‌خواد کار کنه. یه روز کارآموزی رفته و K دقیقه کار می‌کنه و از فرداش که روز اوله بنا به قوانینی کار میکنه، به‌طوری که هر روز $\frac{1}{3}$روز قبل کار میکنه. آرسام حدودا چقدر کار خواهد کرد؟
> #### $k + \frac{k}{3}+ \frac{k}{9}+ ...= k\left(1 + \frac{1}{3}+ \frac{1}{9}+ ...\right)= k(\frac{1}{1-\frac{1}{3}}) = \frac{3k}{2}$
> ---
>> ### * خواص لگاریتم
> * $\log_b (xy) = \log_b x + \log_b y$
> * $\log_b \left(\frac{x}{y}\right) = \log_b x - \log_b y$
> * $\log_b x^n = n \log_b x$
> * $\log_b x = \frac{\log_k x}{\log_k b}$
> * $\log_b x = \frac{1}{\log_x b}$
> * $b^{\log_b x} = x$
>
> * $\log_{b^n} x^m = \frac{m}{n} \log_b x$

# رشد توابع
اگر با میل n  به $\infty$، دو تابع f و g صعود کنن، تابعی رشدش بیشتره که زودتر به بی‌نهایت برسه

به طور کلی حد $\lim_{n \to \infty} \frac{f(n)}{g(n)}$ وقتی $n \to \infty$ سه حالت دارد:

* جواب صفر باشد، رشد g بیشتره
* جواب $\infty$ باشد، رشد f بیشتره
* جواب عدد ثابتی باشد، هر دو هم‌رشد هستن

اگر هم با مبهم $\frac{0}{0}$و $\frac{\infty}{\infty}$مواجه شدیم، می‌توان از هوپیتال و حذف عامل مبهم کننده استفاده کرد.

$$ (\ln n)' = \frac{1}{n}$$
$$(\log_a n)' = \frac{1}{n \ln a}$$
$$(\sqrt{n})' = \frac{1}{2\sqrt{n}}$$

#### مثال: $f(n) = 3n^2 + 5n$ و $g(n) = 20n \log_2 n$

برای مقایسه رشد $f(n)$ و $g(n)$، حد نسبت آن‌ها را هنگامی که $n \to \infty$ می‌گیریم:

$$\lim_{n \to \infty} \frac{f(n)}{g(n)} = \lim_{n \to \infty} \frac{3n^2 + 5n}{20n \log_2 n} = \lim_{n \to \infty} \frac{n(3n + 5)}{n(20 \log_2 n)} = \lim_{n \to \infty} \frac{3n + 5}{20 \log_2 n} = \frac{\infty}{\infty}$$
به مبهم رسیدیم و با هوپیتال پیش میریم:
$$\lim_{n \to \infty} \frac{3}{\frac{20}{n \ln 2}} = \lim_{n \to \infty} \frac{3n \ln 2}{20} =\frac{3(\infty) \ln 2}{20} = \infty$$

از روی تعریف داده شده در جزوه:

$$\lim_{n \to \infty} \frac{f(n)}{g(n)} = \infty \quad \leftrightarrow \quad \text{رشد } f(n) > \text{رشد } g(n)$$

بنابراین، **رشد تابع $f(n)$ از رشد تابع $g(n)$ بیشتر است.**

###  لگ استار ($\log^* n$) 

**تعداد بارهایی که باید تابع لگاریتم (معمولاً با مبنای ۲) را روی عدد $n$ اعمال کنیم تا نتیجه‌ی نهایی عددی کوچک‌تر یا مساوی ۱ شود**


#### مثال : فرض کنید $\log n$ به معنای $\log_2 n$ است (لگاریتم در مبنای ۲).

بیایید $\log^* (65536)$ را محاسبه کنیم:

**مرحله ۱:** $\log_2 (65536) = 16$

**مرحله ۲:** $\log_2 (16) = 4$

**مرحله ۳:** $\log_2 (4) = 2$

**مرحله ۴:** $\log_2 (2) = 1$

**نتیجه:** چون در این مرحله نتیجه $\le 1$ شد، تعداد تکرارها را می‌شماریم.

$\log^* (65536) = 4$

> $$\log^∗(\log n)=(\log^∗n)-1$$

#### چند نکته راجع به مقایسه رشد توابع:

۱) ضرب ثابت تأثیری در رشد ندارد. 
$$\theta(n^2) = \theta(4n^2)$$

۲) رشد یک چندجمله‌ای با رشد جمله‌ی با بیشترین درجه‌اش مساوی است؛ یعنی:
$$a_p n^p + a_{p-1} n^{p-1} + \dots + a_1 n + a_0 \sim a_p n^p = \theta(n^p)$$

۳) پایه ثابت لگاریتم تأثیری در رشد ندارد؛ یعنی $\log_b n$ و $\log_a n$ هم رشد هستند ($a, b > 1$ ثابت).

۴) رشد توابع نمایی از رشد چندجمله‌ای بیشتر است؛ یعنی رشد $a^n$ از $n^b$ بیشتر است ($a > 1$ و $b$ ثابت).

۵) رشد $\log^b n = (\log n)^b$ همیشه بیشتر است از $a^n$ ($a, b$ ثابت و $a > ۰$).

۶) رشد $n^n$ از رشد $n!$ بیشتر است.

۷) رشد $\lg(n!)$ با رشد $n\cdot\lg n$ مساوی است.

#### در کل داریم:
$$ \theta(1) < \theta(\log^* n) < \theta(\log\log n) < \theta(\log n) < \theta(\sqrt{n}) < \theta(n) < \theta(n \log n) < \theta(n^c) < \theta(c^n) < \theta(n!) < \theta(n^n)$$

# نماد های مجانبی
### نماد $O$ (Big O)

این نماد **حداکثر زمان یا حافظه‌ای** را نشان می‌دهد که الگوریتم برای تکمیل کار نیاز دارد. به عبارتی، می‌گوید رشد تابع عملکرد **از این مقدار بیشتر نخواهد شد**.

**مثال:** اگر یک الگوریتم $O(n^2)$ باشد، یعنی در بدترین حالت، زمان اجرای آن به اندازه مربع اندازه ورودی ($n^2$) رشد می‌کند.
### نماد $o$ (Small O)

اگر $f(n) = o(g(n))$ باشد، یعنی **رشد $f(n)$ به مراتب از $g(n)$ کندتر است** و **هیچ گاه** رشد یکسانی با آن ندارد. به عبارت دیگر، $f(n)$ یک کران بالای محکم برای $g(n)$ نیست.

**تفاوت با $O$:** $O$ یعنی "رشد **حداکثر** اینقدر است" (ممکن است یکسان هم باشند). $o$ یعنی "رشد **حتماً کمتر** از این است". برای مثال، $n^2 = O(n^2)$ درست است، اما $n^2 = o(n^2)$ **غلط** است.

### نماد $\Omega$ (Big Omega)

این نماد **حداقل زمان یا حافظه‌ای** را نشان می‌دهد که الگوریتم برای تکمیل کار نیاز دارد. به عبارتی، می‌گوید رشد تابع عملکرد **از این مقدار کمتر نخواهد شد**.

**مثال:** اگر یک الگوریتم $\Omega(n)$ باشد، یعنی در بهترین حالت، زمان اجرای آن حداقل خطی ($n$) خواهد بود.
### نماد $\omega$ (Small Omega)

اگر $f(n) = \omega(g(n))$ باشد، یعنی **رشد $f(n)$ به مراتب از $g(n)$ سریع‌تر است** و **هیچ گاه** رشد یکسانی با آن ندارد. به عبارت دیگر، $f(n)$ یک کران پایین محکم برای $g(n)$ نیست.

**تفاوت با $\Omega$:** $\Omega$ یعنی "رشد **حداقل** اینقدر است" (ممکن است یکسان هم باشند). $\omega$ یعنی "رشد **حتماً بیشتر** از این است". برای مثال، $n^2 = \Omega(n^2)$ درست است، اما $n^2 = \omega(n^2)$ **غلط** است.
### نماد $\theta$ (Big Theta)


این نماد زمانی استفاده می‌شود که کران بالا ($O$) و کران پایین ($\Omega$) برای یک الگوریتم یکسان باشند. این نماد **رشد واقعی و دقیق** الگوریتم را نشان می‌دهد.

**مثال:** اگر یک الگوریتم $\theta(n \log n)$ باشد، یعنی زمان اجرای آن تقریباً **همیشه** متناسب با $n \log n$ خواهد بود.






## خلاصه تفاوت بین نمادهای $O , o , \Omega , \omega ,\theta$

| نماد | اسم | رابطه | مفهوم ساده |
| :--- | :--- | :--- | :--- |
| **$O$** | Big O | $f(n) \le c \cdot g(n)$ | $f$ **حداکثر به اندازه** $g$ رشد می‌کند. |
| **$o$** | Small O | $\lim f/g = 0$ | $f$ **اکیداً کندتر** از $g$ رشد می‌کند. |
| **$\Omega$** | Big Omega | $f(n) \ge c \cdot g(n)$ | $f$ **حداقل به اندازه** $g$ رشد می‌کند. |
| **$\omega$** | Small Omega | $\lim f/g = \infty$ | $f$ **اکیداً سریع‌تر** از $g$ رشد می‌کند. |
| **$\theta$** | Big Theta | $c_1 g(n) \le f(n) \le c_2 g(n)$ | $f$ **دقیقاً به اندازه** $g$ رشد می‌کند. |

### روابط بین نماد ها
$$f(n) \in \theta(g(n)) \iff f(n) \in O(g(n)) \land f(n) \in \Omega(g(n))$$
$$f(n) \in \theta(f(n)), \quad f(n) \in O(f(n)), \quad f(n) \in \Omega(f(n))$$
$$f(n) \in \theta(g(n)) \iff g(n) \in \theta(f(n))$$
$$f(n) \in \theta(g(n)) \land g(n) \in \theta(h(n)) \Rightarrow f(n) \in \theta(h(n))$$
$$f(n) \in O(g(n)) \iff g(n) \in \Omega(f(n))$$
$$O(f(n)) \cap \Omega(f(n)) = \theta(f(n))$$
$$f(n) + g(n) \in \theta(\max\{f(n), g(n)\})$$


##  مفهوم محدودیت چندجمله‌ای

تابع $f$ را **محدود به چندجمله‌ای** می‌گوییم هرگاه یک عدد $a$ وجود داشته باشد به طوری که:
$$f(n) \le n^a$$ 

### روش تست لگاریتمی

برای بررسی این شرط، می‌توان از لگاریتم استفاده کرد. اگر لگاریتم تابع $f$ رشدی کمتر یا مساوی با لگاریتم $n^a$ داشته باشد، آن تابع محدود به چندجمله‌ای است:
$$\log f \le \log n^a \longrightarrow \log f \le a \log n$$
به زبان ساده، اگر $\log f$ از جنس $\theta(\log n)$ باشد، شرط برقرار است


#### مثال : بررسی تابع $[\log n]!$

آیا فاکتوریلِ لگاریتم $n$ محدود به چندجمله‌ای است؟
برای بررسی، از طرفین لگاریتم می‌گیریم و از هم‌ارزی استرلینگ ($\log n! \sim n \log n$) استفاده می‌کنیم:
$$\log([\log n]!) \sim \lceil \log n \rceil \times \log(\lceil \log n \rceil)$$
$$\sim \log n \times \log \log n$$
چون حاصل ($\log n \log \log n$) از $\log n$ بزرگتر است، پس این تابع **محدود به چندجمله‌ای نیست**.

#### مثال : بررسی تابع $[\log \log n]!$

با گرفتن لگاریتم از این تابع:
$$\log([\log \log n]!) \sim [\log \log n] \times \log([\log \log n])$$
$$\sim \log \log n \times \log \log \log n < (\log \log n)^2$$
چون $(\log \log n)^2$ از $\log n$ کوچکتر است، پس این تابع **محدود به چندجمله‌ای است**.


## تحلیل حلقه‌های ساده و تودرتو

در این بخش زمان اجرای کدهای پایه را بررسی می‌کنیم.

### حلقه‌های مستقل 
اگر حلقه‌ها وابستگی نداشته باشند، تعداد تکرارها در هم ضرب می‌شود.

**حلقه ساده:** $n \to \theta(n)$
```c
for (int i = 1; i <= n; i++) {

    printf("silaAAm"); 
}
```
**دو حلقه تودرتو:** $n \times n \to \theta(n^2)$
```c
for (int i = 1; i <= n; i++) {

    for (int j = 1; j <= n; j++) {
        printf("Aksu sazan shomal gharb");
    }
}
```
**سه حلقه تودرتو:** $n \times n \times n \to \theta(n^3)$
```c
for (int i = 1; i <= n; i++) {

    for (int j = 1; j <= n; j++) {

        for (int k = 1; k <= n; k++) {
            printf("Badihieh");
        }
    }
}
```
### حلقه‌های وابسته 

زمانی که شمارنده حلقه داخلی به شمارنده حلقه بیرونی وابسته باشد.

#### حالت ۱: وابستگی ساده (مثلثی)

```c
for(i = 1 to n) {
   for(j = 1 to i) {
       printf('abbas bouazar');
   }
}
```

تعداد اجرا برابر است با مجموع اعداد ۱ تا $n$:
$$\sum_{i=1}^{n} i = \frac{n(n+1)}{2} = \theta(n^2)$$

#### حالت ۲: وابستگی سه گانه

اگر سه حلقه داشته باشیم که هر کدام به قبلی وابسته باشد ($k$ تا $j$، و $j$ تا $i$):
```c
for (int i = 1; i <= n; i++) {
    
    for (int j = 1; j <= i; j++) {

        for (int k = 1; k <= j; k++) {
            printf("Mr.Hashemi?");
        }
    }
}
```
$$\sum_{i=1}^{n} \sum_{j=1}^{i} j \approx \sum_{i=1}^{n} \frac{i^2}{2} \approx \frac{n^3}{6} = \theta(n^3)$$
## تحلیل حلقه‌های با گام‌های خاص

### الگوی هارمونیک

اگر گام حلقه داخلی به شمارنده حلقه بیرونی وابسته باشد ($j$ با گام $i$ جلو برود):

```c
for(i = 1; i <= n; i++) {
   for(j = 1; j <= n; j = j + i) { 
       printf('He he he!');
   }
}
```

تعداد دفعات اجرای حلقه داخلی برای هر $i$ برابر است با $\frac{n}{i}$. مجموع کل دفعات:
$$\sum_{i=1}^{n} \frac{n}{i} = n \sum_{i=1}^{n} \frac{1}{i} \approx n \ln n = \theta(n \log n)$$

### الگوی هندسی نزولی 

اگر در حلقه داخلی شمارنده تقسیم بر ۲ شود یا شرط توقف به صورت توانی کم شود،
تعداد اجراها به صورت سری هندسی $n/2 + n/4 + n/8 + \dots$ خواهد بود که مجموع آن همگرا به $n$ است.
**نتیجه:** $\theta(n)$.
```c
for(i = 1; i <= n; i++){

    for(j = 1; j <= n; j++){ 
        printf('mes songon');
        n--; 
    }
}
```
### الگوی حسابی نزولی 

اگر حلقه بیرونی خطی باشد و حلقه داخلی هر بار یکی کمتر اجرا شود ($n, n-1, n-2 \dots$)
این همان سری حسابی است و نتیجه $\theta(n^2)$ می‌باشد.
```c
for(i = 1; i <= n; i++){

    for(j = 1; j <= n; j++){ 
        printf('Abnabat yarain?');
    }
    n--;
}
```
## حلقه‌های لگاریتمی و توانی

### ضرب در ۲ 

```c
for(i = 1; i <= n; i = i * 2) { ... }
```

وقتی متغیر حلقه در هر مرحله دو برابر می‌شود، تعداد تکرار برابر با $\log_2 n$ است.
**نتیجه:** $\theta(\log n)$.

### توان ۲ 

```c
i = 2;
while(i < n) {
    i = i * i;
}
```

دنباله مقادیر $i$ به صورت $2, 2^2, 2^4, 2^8, \dots, 2^{2^k}$ رشد می‌کند.
شرط توقف: $2^{2^k} \approx n \Rightarrow 2^k \approx \log n \Rightarrow k \approx \log \log n$.
**نتیجه:** $\theta(\log \log n)$.

**نکته:** اگر دستور به صورت $i = i^3$ باشد، نتیجه $\log_3 \log_2 n$ خواهد بود.

## تحلیل ترکیبی حلقه‌های پیچیده 

این بخش شامل سخت‌ترین مثال‌های تحلیل الگوریتم است که در آن حلقه‌ها وابستگی‌های غیرخطی دارند.

### الف) حلقه بیرونی هندسی، حلقه داخلی ساده

```c
for(i = 1; i <= n; i = i * 2) {
    for(j = 1; j <= i; j++) { 
        printf('haji shahr farsh!');
    }
}
```

مقادیر $i$ عبارتند از $1, 2, 4, 8, \dots, n$.
تعداد کل اجرا برابر است با مجموع این مقادیر (سری هندسی):
$$1 + 2 + 4 + \dots + n = 2n - 1 = \theta(n)$$
**نکته:** با اینکه حلقه بیرونی لگاریتمی است، اما رشد نمایی تعداد تکرارهای داخلی باعث می‌شود کل زمان اجرا خطی شود.

### ب) حلقه بیرونی هندسی، حلقه داخلی هندسی (وابسته)

```c
for(i = 1; i <= n; i = i * 2) {
    for(j = 1; j <= i; j = j * 2) {
        printf('ali parvin');
    }
}
```

تعداد اجراهای داخلی برابر است با $\log i$.
مجموع کل: $\sum \log i$ روی توان‌های ۲.
مقادیر $\log i$ عبارتند از: $\log 1, \log 2, \log 4, \dots, \log n$ که می‌شود $0, 1, 2, \dots, \log n$.
این یک تصاعد حسابی است تا $k = \log n$.
مجموع: $\frac{k(k+1)}{2} \approx \frac{(\log n)^2}{2}$.
**نتیجه:** $\theta(\log^2 n)$.

### ج) حلقه بیرونی خطی، حلقه داخلی هندسی (وابسته)

```c
for(i = 1; i <= n; i++) { 
    for(j = 1; j <= i; j = j * 2) {
        printf('sib is good');
    }
}
```

تعداد تکرار: $\sum_{i=1}^{n} \log i$.
طبق خواص لگاریتم: $\sum \log i = \log(1 \times 2 \times \dots \times n) = \log(n!)$.
طبق تقریب استرلینگ $\log(n!) = \theta(n \log n)$.
**نتیجه:** $\theta(n \log n)$.

--- 
# سوالات تحکیمی
#### 1.مرتبه خروجی تابع زیر کدام است؟

```c
Func (n)
    tmp = 0;
    for (i = n/2 ; i <= n; i++){
        for (j= 2;j <=n;j= 2j){
            tmp = tmp + i; 
        }
    }        
    return tmp;
```


1.  $\Theta(n \log n)$
2.  $\Theta(n^2)$
3.  $\Theta(n^2 \log n)$
4.  $\Theta(n^3)$

>**گزینه صحیح ارسالی:** 3
>
>**استدلال ارسالی:**
>حلقه بیرونی $\frac{n}{2}$ مرتبه و حلقه داخلی $\Theta(\log n)$ مرتبه اجرا می‌شود، بنابراین تعداد دفعات اجرای عبارت داخلی برابر $\Theta(n \log n)$ می‌باشد و چون این عبارت با مقدار $\frac{n}{2}$ افزایش می‌یابد بنابراین خروجی از مرتبه $\Theta(n^2 \log n)$ می‌باشد.

-----

#### 2.کدام گزاره‌های زیر درست هستند؟

**a**. $3n^2 2^n + 5n\log(n) \in o(n^2 2^n)$

**b**. $n! \in \omega(n\log(n))$

**c**. $n^2\log(n) \in \theta\bigl(n(\log(n))^2\bigr)$

**d**. $n^2 \in O\bigl(\frac{n^2}{\log(n)}\bigr)$

**e**. $n^2 = o(n\log(n))$

**f**. $n = o(n\log(n))$

**g**. $n^2 = \Omega(n\log(n))$

>a.نادرست [دقت](#نماد--small-o)
>
>b.درست
>
>c.  نادرست. در $(n(n\log n))$ و $(\log n(n\log n))$ قسمت $(n\log n)$ رشد برابری دارن و رشد کلی به رشد $n$ و $\log n$ بستگی دارد که رشد $n$ بیشتره.
>
>d. نادرست $\lim_{n \to \infty} \frac{n^2}{\frac{n^2}{\log(n)}} = \lim_{n \to \infty} \log(n) = \infty$ پس رشد $n^2$ بیشتره
>
>e. نادرست. چون $(n^2)$ خیلی سریع‌تر از $(n\log n)$ رشد می‌کند، نه کندتر.
>
>f. درست
>
>g. درست
--- 

#### 3.مرتبه زمانی شبه‌کد زیر را محاسبه کنید:

```c
for(i = 1; i <= n; i++){
    for(j = 1; j <= n; j++){
        printf("mohandes -> delester");
        n--;
    }
}
```
> [$\theta(n)$](#الگوی-هندسی-نزولی)
--- 
#### 4.مرتبه زمانی شبه‌کد زیر را محاسبه کنید:
```c
for(i = 1; i <= n; i++){
    for(j = 1; j <= n; j++)
        printf("BTS");
    j = 1;
    while(j < n){
        printf("Base Transceiver Station");
        j = j * 2;
    }
}
```
> حلقه بیرونی $n$ بار، اولین حلقه داخلی $n$ بار و دومین حلقه داخلی $\log n$ بار تکرار می‌شود که داریم:
>
>$$n(n +\log n) = n^2 + n\log n = \theta(n^2)$$
--- 
#### 5.مرتبه زمانی شبه‌کد زیر را محاسبه کنید:

```c
for(i = 1; i <= n; i = i * 2)
    for(j = 1; j <= n; j = j * 2)
        for(k = 1; k <= j; k++)
            printf("No Smoking");
```
> $$\log n(2n-1) = 2n\log n -\log n = \theta(n \log n)


